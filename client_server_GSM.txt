Establishing a connection between an "edge" device and a server via GSM to send and request data 

client.py


import serial
import time
import hmac
import hashlib
from cryptography.fernet import Fernet
from random import randint

# Secret keys for HMAC and Fernet (should be securely shared)
HMAC_KEY = b'secret_hmac_key'  
FERNET_KEY = Fernet.generate_key()  
cipher = Fernet(FERNET_KEY)

def read_temperature():
    return randint(20, 30)

def send_sms(ser, recipient, message):
    ser.write(b'AT+CMGF=1\r')
    time.sleep(1)
    ser.write(f'AT+CMGS="{recipient}"\r'.encode())
    time.sleep(1)
    ser.write(f'{message}\r'.encode())
    ser.write(b'\x1A')  # Send SMS (Ctrl+Z)
    time.sleep(3)

def generate_hmac(message):
    return hmac.new(HMAC_KEY, message, hashlib.sha256).digest()

def check_for_sms(ser):
    ser.write(b'AT+CMGF=1\r')
    time.sleep(1)
    ser.write(b'AT+CMGL="ALL"\r')
    time.sleep(1)
    messages = ser.readlines()
    for msg in messages:
        if "TEMP_REQUEST" in msg.decode():
            return True
    return False

def main():
    ser = serial.Serial('/dev/ttyUSB0', 9600, timeout=1)
    time.sleep(2)

    while True:
        if check_for_sms(ser):
            temperature = read_temperature()
            data = f"Current temperature: {temperature}Â°C".encode()

            # Encrypt the data
            encrypted_data = cipher.encrypt(data)

            # Generate HMAC
            hmac_value = generate_hmac(encrypted_data)

            # Combine encrypted data with HMAC (separated by ':')
            message_to_send = f"{encrypted_data.decode()}:{hmac_value.hex()}"

            # Send the combined message
            send_sms(ser, "+1234567890", message_to_send)  
        time.sleep(10)

if __name__ == "__main__":
    main()




server.py


import serial
import time
import hmac
import hashlib
from cryptography.fernet import Fernet

# Secret keys for HMAC and Fernet (should be securely shared)
HMAC_KEY = b'secret_hmac_key'  
FERNET_KEY = Fernet.generate_key()  
cipher = Fernet(FERNET_KEY)

def send_sms(ser, recipient, message):
    ser.write(b'AT+CMGF=1\r')  
    time.sleep(1)
    ser.write(f'AT+CMGS="{recipient}"\r'.encode())
    time.sleep(1)
    ser.write(f'{message}\r'.encode())
    ser.write(b'\x1A')  # Send SMS (Ctrl+Z)
    time.sleep(3)

def read_sms(ser):
    ser.write(b'AT+CMGF=1\r')  # Set SMS mode to text
    time.sleep(1)
    ser.write(b'AT+CMGL="ALL"\r') 
    time.sleep(1)
    messages = ser.readlines()
    for msg in messages:
        if b"Current temperature" in msg:
            return msg.decode().strip()
    return None

def verify_hmac(message, hmac_to_verify):
    calculated_hmac = hmac.new(HMAC_KEY, message, hashlib.sha256).digest()
    return hmac.compare_digest(calculated_hmac, hmac_to_verify)

def main():
    ser = serial.Serial('/dev/ttyUSB0', 9600, timeout=1)
    time.sleep(2)

    send_sms(ser, "+0987654321", "TEMP_REQUEST")  

    while True:
        response = read_sms(ser)
        if response:
            # Split response into the encrypted message and the HMAC
            encrypted_message, received_hmac = response.split(':')
            encrypted_message = encrypted_message.encode()
            received_hmac = bytes.fromhex(received_hmac)

            if verify_hmac(encrypted_message, received_hmac):
                decrypted_message = cipher.decrypt(encrypted_message)
                print(f"Received data from edge device: {decrypted_message.decode()}")
            else:
                print("HMAC verification failed! Data integrity compromised.")
            break
        time.sleep(10)

if __name__ == "__main__":
    main()





How is data transferred using the GSM ?

. ser = serial.Serial('/dev/ttyUSB0', 9600, timeout=1)
  
  This line establishes a serial connection to the GSM modem connected to the specified 
  port (/dev/ttyUSB0). The communication happens at a baud rate of 9600. The timeout=1 
  specifies that if no data is received within 1 second, the read operations will timeout.

. send_sms(ser, "+0987654321", "TEMP_REQUEST")

  This sends an SMS to the edge device (client) requesting temperature data. The 
  TEMP_REQUEST keyword is used to indicate the nature of the request.

. response = read_sms(ser)

  The program reads incoming SMS messages using the read_sms function. If a message 
  containing the temperature data is found, it is returned

. time.sleep(10)

  If no message is found, the program waits for 10 seconds before checking again, to 
  prevent overwhelming the modem with requests.


/dev/ttyUSB0

Definition:

/dev/ttyUSB0 is a device file in Unix-like operating systems (like Linux) that represents a serial communication port. The ttyUSB prefix indicates that this is a USB-based serial port, and 0 indicates the first such port detected by the system.
Device files in /dev/ are special files that provide an interface to hardware devices.

Example:

If you connect a USB-to-Serial adapter (e.g., to communicate with a GSM modem or an Arduino) to your computer, the operating system assigns it a device file like /dev/ttyUSB0. If you connect a second adapter, it might be assigned /dev/ttyUSB1, and so on.

Baud Rate

Definition:

The baud rate is the speed at which data is transmitted over a serial connection, measured in bits per second (bps). Both communicating devices (e.g., computer and GSM modem) must be set to the same baud rate to correctly interpret the data being sent and received.

Example:

Suppose the baud rate is set to 9600 bps. This means 9600 bits are transmitted per second.

Timeout

Definition:

The timeout specifies the maximum amount of time (in seconds) that the program will wait for data to be received from the serial port before giving up. If no data is received within this time, the read operation will fail or return an empty result.

Here, timeout=1 means that the program will wait up to 1 second for data to arrive from the GSM modem. If nothing is received, the program will move on. This prevents the program from hanging indefinitely if no data is available.









  
















